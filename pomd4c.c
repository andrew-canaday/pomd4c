/*============================================================================*
 * Copyright (c) 2021 Andrew T. Canaday
 *
 * This file is part of pomd4c, which is licensed under the MIT license.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *----------------------------------------------------------------------------*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <limits.h>
#include <fcntl.h>

#ifdef __linux__
#include <sys/types.h>
#include <sys/wait.h>
#endif /* __linux__ */

#include <sys/errno.h>
#include <sys/mman.h>
#include <sys/stat.h>

/** # POMD4C
 *
 * `pomd4c` is a _very simplistic_ doc generator for C projects, e.g.:
 *
 * This markdown document can be generated by running:
 *
 * ```bash
 * gcc ./pomd4c.c -o ./pomd4c \
 *     && ./pomd4c ./pomd4c.c > ./API.md
 * ```
 *
 * ## Mechanics
 *
 * `pomd4c` is a little hack — *it is not a C parser or proper document
 * generator*.
 *
 * ### This is all that it does:
 *
 * 1. Reads one or more files, specified on the command line.
 * 1. Emits markdown on `stdout` (errors/debug messages on `stderr`).
 *
 * > :warning: **NOTE**: `pomd4c` _assumes input which has already passed
 * > muster for an actual C parser._ It's not strict or even very robust.
 *
 * The only thing it tries to do is — given a _valid_ C header or source file —
 * figure out which bits are comments and which bits are
 * definitions/declarations immediately following comments.
 *
 * Afterwards, it spits them back out with the C defs wrapped in markdown
 * code fences and the comments emitted verbatim, save for:
 *
 *  - the leading `'/'`, `'*'`, `'*'`, sequence on the first line
 *  - the first `POMD4C_SKIP_COLS` columns of any subsequent lines
 *  - the trailing `'*'`, `'/'`, `'\n'` sequence
 *
 *
 * ### This is how it works:
 *
 * 1. It looks for the character sequence `'/'`, `'*'`, `'*'`.
 *    (i.e. a doc comment start)
 * 1. Then it looks for the sequence `'*'`, `'/'`, `'\n'`.
 *    (i.e. a comment end)
 * 1. Afterwards, it reads whatever follows like so:
 *     - If the next thing that happens is `'\n'` the comment stands on its own.
 *     - Otherwise, it'll read until it reaches the end of the current def/decl.
 *
 * If there are characters in the sequence `"{}()"`, it factors in nesting
 * levels in the most simplistic way possible.
 *
 * That's it!
 *
 * ---
 */

/** # API */

/** ## Definitions
 */

/* HACK: fixed-sized input buffer (read in chunks on a loop) */
#ifndef BUF_SIZE
# define BUF_SIZE 8192
#endif /* BUF_SIZE */

#ifndef ENV_BUF_SIZE
# define ENV_BUF_SIZE 4096
#endif /* ENV_BUF_SIZE */

#ifndef PARAM_PREFIX
# define PARAM_PREFIX "POMD4C_P_"
#endif /* PARAM_PREFIX */

/** Standard output, if -v: */
#define LOG_INFO(fmt, ...) \
    do { \
        if( config.verbose > 0 ) { \
            fprintf(stderr, "pomd4c "POMD4C_VERSION": "fmt"\n", __VA_ARGS__); \
        } \
    } while(0)

/** Debug output, if -vv: */
#define LOG_DEBUG(fmt, ...) \
    do { \
        if( config.verbose > 1 ) { \
            fprintf(stderr, "DEBUG: "fmt"\n", __VA_ARGS__); \
        } \
    } while(0)

/** Trace output, if -vvv: */
#define LOG_TRACE(fmt, ...) \
    do { \
        if( config.verbose > 2 ) { \
            fprintf(stderr, "TRACE: "fmt"\n", __VA_ARGS__); \
        } \
    } while(0)

/** Simple warning log function */
#define LOG_WARNING(fmt, ...) \
    fprintf(stderr, "\033[00;34mWARNING: "fmt"\033[00;m\n", __VA_ARGS__)

/** Simple error log function */
#define LOG_ERROR(fmt, ...) \
    fprintf(stderr, "\033[00;31mERROR: "fmt"\033[00;m\n", __VA_ARGS__)

/** Log a formatted string message and `exit(1)`. */
#define ERROR_BAIL(fmt, ...) \
    LOG_ERROR(fmt, __VA_ARGS__); \
    exit(1)

/** Log a plain string message and `exit(1)`. */
#define ERROR_BAIL_MSG(msg) ERROR_BAIL("%s", msg)

/** Version number as a string literal. */
#ifndef POMD4C_VERSION
#define POMD4C_VERSION "0.9.0"
#endif /* POMD4C_VERSION */

/** ## Types
 */

/** ### parser_state_t
 *
 * Enum used to track the present state of the parser.
 */
typedef enum parser_state {
    PARSE_FILE,          /* Looking for doc comment start */
    PARSE_OPEN_SLASH,    /* Saw the initial '/', looking for '*' */
    PARSE_STAR,          /* Saw '*' after '/', looking for another */
    PARSE_SPACE,         /* Saw '*' after '*', skip leading spaces */
    PARSE_COMMENT,       /* Parsing comment (skips first 3 columns) */
    PARSE_NEWLINE,       /* Looking for newline after comment */
    PARSE_DEF_START,     /* Def parsing (optional) begins (skips leading ' ')*/
    PARSE_DEF,           /* Parsing the actual C def, looking for a LF */
    PARSE_DEF_END        /* End of def parsing */
} parser_state_t;


/** ## Globals */

/* Settings: */
const long DEFAULT_SKIP_COLS = 3;


/** Runtime config */
static struct {
    unsigned int verbose;                  /* Verbosity */
    unsigned     skip_cols;                /* Number of columns to skip */
    const char*  post_path;                /* Post-processor path */
    const char*  tmpdir;                   /* User TMPDIR */
    const char*  input_path;               /* The current input file */
    char         abs_input_path[PATH_MAX]; /* Absolute path to current input */
    char         comment_path[PATH_MAX];   /* Path to the comment output */
    char         source_path[PATH_MAX];    /* Path to the source output */
    FILE*        comment_out;              /* Current comment output*/
    FILE*        source_out;               /* Current source output*/
} config;


static const char* STATE_NAMES[] = {
    "PARSE_FILE",
    "PARSE_OPEN_SLASH",
    "PARSE_STAR",
    "PARSE_SPACE",
    "PARSE_COMMENT",
    "PARSE_NEWLINE",
    "PARSE_DEF_START",
    "PARSE_DEF",
    "PARSE_DEF_END"
};

/** Struct used to encapsulate parser information/house output buffer. */
static struct {
    /* parser/input info: */
    parser_state_t state;             /* Current parser state */
    char           buffer[BUF_SIZE];  /* Parse temp buffer */
    size_t         row;               /* Row number in the input. */
    size_t         col;               /* Column number in the input. */
    ssize_t        nest_lvl;          /* Tracks nesting */

    /* content pointers: */
    const char*    heading;           /* Heading, if present */
    const char*    summary;           /* First line of comment */
    const char*    def;               /* Beginning of C def (optional) */
    size_t         len;               /* Number of bytes written to buffer. */

    /* parse state specifics: */
    char*          recv;              /* Current input pointer for buffer */
    char           last_saved;        /* Last char actually stored in buffer */
    char           last_seen;         /* Last char actually seen in file */
    int            is_macro;          /* Flag indicating macro def vs other */
} parser;


/** ## Functions
 *
 * Prototypes for illustration purposes only.
 *
 * _**WARNING**: DO NOT EAT. DO NOT INCINERATE._
 *
 */

/** ### parser_reset
 *
 * Reset the parser to initial state.
 */
static void parser_reset(void);

/** ### parser_write
 *
 * Unconditionally write a single character to the parser's output buffer.
 *
 *  - `parser` a pointer to the current `parse_info_t`
 *  - `c` the character to write to the buffer
 */
static void parser_write(char c);

/** ### parser_write_comment
 *
 * Write a single character to the parser's output buffer IF the character is
 * a newline or the current column is greater than config.skip_cols.
 *
 *  - `parser` a pointer to the current `parse_info_t`
 *  - `c` the character to write to the buffer
 */
static int parser_write_comment(char c);

/** ### parser_emit
 *
 * Emit the parsers output buffer as markdown output is STDOUT. Output buffer
 * is emitted verbatim if -p has been specified.
 */
static void parser_emit(void);

/** ### parse_comment
 *
 * Invoked by `parse` to parse a comment body.
 */
static void parse_comment(char c);

/** ### parse_def_start
 *
 * Invoked by `parse` to look for a C def after a comment end.
 */
static void parse_def_start(char c);

/** ### parse_def
 *
 * Invoked by `parse` to parse a C definition/declaration.
 */
static void parse_def(char c);

/** ### parse
 *
 * Parse the given input buffer.
 */
static ssize_t parse(char* read_buf, size_t len);


/*--------------------------------------------------
 * Functions:
 *--------------------------------------------------*/
static void parser_reset(void)
{
    memset(&parser, 0, sizeof(parser));
    parser.recv = parser.buffer;
    parser.row = 1;
    return;
}


static void parser_write(char c)
{
#ifdef POMD4C_CHECK_PRINTABLE
    if( c != '\0' && !isprint(c) ) {
        return;
    }
#endif /* POMD4C_CHECK_PRINTABLE */

    *(parser.recv++) = c;
    parser.last_saved = c;
    parser.len++;
    return;
}


/* Always write newlines. All other chars are written if the column is
 * greater than config.skip_cols: */
static int is_comment_content(char c)
{
    if( c == '\n' || parser.col > config.skip_cols ) {
        return 1;
    }
    return 0;
}

/* This bit is used to facilitate writing headings on the same line as the
 * initial slash-star-star: */
static int is_heading(char c)
{
    if( c != ' ' && parser.col > (config.skip_cols-1) ) {
        return 1;
    }
    return 0;
}

static int parser_write_comment(char c)
{
    if( is_comment_content(c) || is_heading(c) ) {
        parser_write(c);
        return 1;
    }
    return 0;
}

static void parser_emit(void)
{
    parser.buffer[BUF_SIZE-1] = '\0'; /* HACK HACK HACK */

    if( config.post_path ) {
        /* comment file: */
        sprintf(config.comment_path, "%s%s", config.tmpdir, "comment-XXXXXX");
        if( !mktemp(config.comment_path) ) {
            goto emit_bail;
        }

        config.comment_out = fopen(config.comment_path, "w");
        if( !config.comment_out ) {
            goto emit_bail;
        }
        LOG_DEBUG("comment tmp file: %s", config.comment_path);
    }

    /* Summary: the only thing, if there's anything at all. */
    fprintf(config.comment_out,"%s\n\n", parser.summary);

    if( config.post_path ) {
        fclose(config.comment_out);
    }

    if( parser.def ) {
        if( config.post_path ) {
            /* source file: */
            sprintf(config.source_path, "%s%s", config.tmpdir, "source-XXXXXX");
            if( !mktemp(config.source_path) ) {
                goto emit_bail;
            }

            config.source_out = fopen(config.source_path, "w");
            if( !config.source_out ) {
                goto emit_bail;
            }
            LOG_DEBUG("source tmp file: %s", config.source_path);
            fprintf(config.source_out,"%s\n", parser.def);
        } else {
            /* Wrap in code fences, if postprocess isn't specified: */
            fprintf(config.source_out,"\n```C\n%s\n```\n\n", parser.def);
        }

        if( config.post_path ) {
            fclose(config.source_out);
        }
    }

    /* Invoke post-processor.
     * TODO:
     * - should we do this all at once at the end?
     * - should we run multiple in parallel?
     */
    if( config.post_path ) {
        pid_t post_pid = fork();

        if( !post_pid ) {
            LOG_DEBUG("Executing: %s", config.post_path);
            setenv("POMD4C_SOURCE", config.abs_input_path, 1);
            setenv("POMD4C_VERSION", POMD4C_VERSION, 1);

            const char* source_path = config.source_path;
            if( !parser.def ) {
                source_path = NULL;
            }
            errno = 0;
            int r_val = execlp(
                    config.post_path, config.post_path,
                    config.comment_path, source_path,
                    NULL);
            LOG_ERROR("Failed to launch post proc %s: %s",
                    config.post_path, strerror(errno));
            exit(1);
        }

        if( post_pid > 0 ) {
            while( (post_pid = waitpid(-1, 0, 0)) > 0 )
            {
                LOG_DEBUG("Waiting on process %i to complete", (int)post_pid);
            }
        } else {
            LOG_ERROR("Postprocessing failed: %s", strerror(errno));
            goto emit_bail;
        }
    }
    return;

emit_bail:
    if( config.post_path ) {
        fclose(config.comment_out);
        remove(config.comment_path);
        fclose(config.source_out);
        remove(config.source_path);
    }
    LOG_ERROR("Failed to write docs: %s", strerror(errno));
    exit(1);
    return;
}


static void parse_comment(char c)
{
    /* Check for end-of-comment: */
    if( c == '/' && parser.last_seen == '*' ) {
        /* Delete that last '*' and write string terminal: */
        parser.recv--;
        parser_write('\0');
        parser.def = parser.recv;
        parser.state++;
    } else {
        parser_write_comment(c);
    }
    return;
}


static void parse_def_start(char c)
{
    switch(c) {
        /* If we hit a newline before anything else: give up on defs + emit. */
        case '\n':
            parser.def = NULL;
            parser_emit();
            parser_reset();
            break;
            /* Else, ignore leading spaces. */
        case ' ':
            /* fallthrough */
        case '\t':
            break;
            /* Okay! We've got something substantive; start parsing the def. */
        case '#':
            parser.is_macro = 1;
            /* fallthrough */
        default:
            parser_write(c);
            parser.state++;
            break;
    }
    return;
}


static void parse_def(char c)
{
    /* If we haven't already decided if we're nested or what characters
     * we're using to check for nesting, check to see if the present
     * character is in "({" and set things up to track nesting. Else, move on.
     */
    switch(c) {
        case '(':
            /* fallthrough */
        case '{':
            parser.nest_lvl++;
            break;
        case ')':
            /* fallthrough */
        case '}':
            parser.nest_lvl--;
            break;
        default:
            break;
    }

    if( c == '\n'
#ifdef POMD4C_BACKSLASH_ESCAPES
            && parser.last_saved != '\\'
#endif /* POMD4C_BACKSLASH_ESCAPES */
            && parser.nest_lvl == 0 ) {
        parser.state = PARSE_DEF_END;
        return;
    }

    /* Whatever it is, write it down: */
    parser_write(c);
    return;
}


static ssize_t parse(char* read_buf, size_t len)
{
    char* src = read_buf;
    size_t idx = 0;
    for(idx=0; idx < len; idx++ ) {
        /* HACK HACK: Store the last character, if there was one. */
        if( idx > 0 ) {
            parser.last_seen = *(src-1);
        }

        char c = *src++;
        LOG_TRACE("%04zu,%04zu:%s: '%c' (seen: %c'; saved: '%c')",
                parser.row, parser.col,
                STATE_NAMES[parser.state], c,
                parser.last_seen,
                parser.last_saved
                );

        if( c == '\n' ) {
            parser.row++;
            parser.col = 0;
        } else {
            parser.col++;
        }

        switch(parser.state) {
            case PARSE_FILE:
                /* Chug along until we hit a '/' */
                if( c == '/' ) {
                    parser.state++;
                }
                break;
            case PARSE_OPEN_SLASH:
                /* We got a '/', so expect a '*'; else: reset! */
                if( c == '*' ) {
                    parser.state++;
                } else {
                    parser_reset();
                }
                break;
            case PARSE_STAR:
                /* We got a '*', so expect another; else: reset! */
                if( c == '*' ) {
                    parser.state++;
                } else {
                    parser_reset();
                }
                break;
            case PARSE_SPACE:
                /* We got a second '*', so expect ' '; else: reset! */
                if( c == ' ' ) {
                    break;
                }
                parser.state++;
                parser.summary = parser.recv;
                /* fallthrough */
            case PARSE_COMMENT:
                parse_comment(c);
                break;
            case PARSE_NEWLINE:
                /* If we hit a newline, output this comment on its own without
                 * looking for a def/decl: */
                if( c == '\n' ) {
                    parser.state++;
                } else {
                    /* Otherwise, start parsing the def text: */
                    parser.def = NULL;
                    parser_emit();
                    parser_reset();
                }
                break;
            case PARSE_DEF_START:
                parse_def_start(c);
                break;
            case PARSE_DEF:
still_in_def:
                parse_def(c);
                break;
                /* HACK HACK HACK */
            case PARSE_DEF_END:
                if( c == '\n' || c == '#' ) {
                    if( parser.is_macro || parser.last_seen == '\n' ) {
                        parser_write('\0');
                        parser_emit();
                        parser_reset();
                    } else {
                        parser_write(c);
                    }
                } else {
                    parser_write('\n'); /* write the LF we skipped */
                    parser.state = PARSE_DEF;
                    goto still_in_def;
                }
                break;
        }
    }
    return idx;
}

#define USAGE_STR \
    "pomd4c "POMD4C_VERSION"\n" \
    "USAGE: %s [OPTIONS] FILE1 [FILE2...FILEN]\n" \
    "OPTIONS:\n" \
    " -h	Usage info (this)\n" \
    " -v	Verbosity (more times == more verbose)\n" \
    " -p	Post-process output script (default: none)\n" \
    " -e	Specify a postprocessor env parameter (multiple ok)\n" \
    "   	(e.g.: pomd4c -e 'my_key=my_value')\n" \
    "\n" \
    "POSTPROCESSING\n" \
    "\n" \
    "  By default, pomd4c simply buffers the contents of special comments\n" \
    "  and any C entitity that follows immediately afterwards. Output is\n" \
    "  direct to STDOUT.\n" \
    "\n" \
    "  To facilitate additional formatting and file handling, pomd4c can\n" \
    "  optionally offload the last step — formatting and file writing —\n" \
    "  to an auxiliary process, e.g.:\n" \
    "\n" \
    "    $ pomd4c -p /path/to/my/script ./my_source.c\n" \
    "\n" \
    "  When a file is first being processed, the post processing script\n" \
    "  will be invoked once with no arguments. The name of the source\n" \
    "  file being processed will be in the env var, POMD4C_SOURCE.\n" \
    "  Afterwards, the process is called once for each doc comment, with\n" \
    "  one or two arguments specified on the command line:\n" \
    "\n" \
    "    $1 — a path to a tmp file containing the doc comment\n" \
    "    $2 — a path to a tmp file containing the corresponding\n" \
    "         source code, if present.\n" \
    "\n" \
    "  STDOUT and STDERR are left open (mind your STDOUT if you're\n" \
    "  leveraging redirects!). Parameters and metadata are provided\n" \
    "  through the env. C entities are NOT wrapped in code fences.\n" \
    "\n" \
    "\n" \
    "PARAMETERS\n" \
    "\n" \
    "  pomd4c provides some limited metadata to postprocessing scripts, by\n" \
    "  way of env vars with a \"POMD4C_\" prefix, e.g.:\n" \
    "\n" \
    "      POMD4C_VERSION:   the current pomd4c version...\n" \
    "      POMD4C_SOURCE:    the path (absolute) to the current source\n" \
    "      POMD4C_SKIP_COLS: number of comment columns to skip   3\n" \
    "\n" \
    "  The environment can be further extended using the -e option, which\n" \
    "  takes arguments in the format \"NAME=value\" and creates environment\n" \
    "  variables with a "PARAM_PREFIX" prefix, e.g.:\n" \
    "      $ pomd4c -p ./my-script.sh -e my_param=value ...\n" \
    "\n" \
    "  Will set the env var "PARAM_PREFIX"_MY_PARAM equal to \"value\"\n" \
    "\n" \
    "\n" \
    "ENVIRONMENT\n" \
    "\n" \
    "  Some pomd4c behavior can be further customized via env vars:\n" \
    "\n" \
    "    NAME:              DESRIPTION:                         DEFAULT:\n" \
    "    POMD4C_SKIP_COLS   Number of comment columns to skip   3\n" \
    "\n"


static void usage(const char* name) {
    fprintf(stderr, USAGE_STR, name);
    return;
}


static int add_env_param(const char* param_str)
{
    char  key[ENV_BUF_SIZE];
    char* value;

    snprintf(key, ENV_BUF_SIZE-1, ""PARAM_PREFIX"%s", param_str);

    value = strchr(key, '=');
    if( value == NULL || *value == '\0' ) {
        errno = EINVAL;
        return -1;
    }

    *value++ = '\0';

    for(char* c=key; *c; c++) {
        *c = toupper(*c);
    }
    errno = 0;
    return setenv(key, value, 1);
}


static int env_as_long(const char* env_name, long* value, const long* def_val)
{
    if( !env_name ) {
        return EINVAL;
    }

    const char* env_s = getenv(env_name);
    if( !env_s ) {
        goto long_env_unset;
    }

    char* endptr;
    long env_l = strtol(env_s, &endptr, 10);
    if( *endptr == '\0' ) {
        *value = env_l;
        return 0;
    }

long_env_unset:
    if( def_val ) {
        *value = *def_val;
        return 0;
    }
    return EINVAL;
}


static int configure_parser(void)
{
    char tmp[ENV_BUF_SIZE];

    /* If not post processing, output is to STDOUT: */
    if( !config.post_path ) {
        config.comment_out = stdout;
        config.source_out = stdout;
    } else {
        LOG_DEBUG("Post processor: %s", config.post_path);
    }

    /* POMD4C_SKIP_COLS: */
    long skip_cols;
    env_as_long("POMD4C_SKIP_COLS", &skip_cols, &DEFAULT_SKIP_COLS);
    if( skip_cols < 0 ) {
        skip_cols = DEFAULT_SKIP_COLS;
    }
    config.skip_cols = skip_cols;
    snprintf(tmp, ENV_BUF_SIZE-1, "%li", skip_cols);
    setenv("POMD4C_SKIP_COLS", tmp, 1);
    return 0;
}


/* main function.
 *
 * All that's happening is:
 *
 *  - check number of args
 *  - open the file whose path is in argv[1]; else bail
 *  - until we've seen `EOF`:
 *      - read `BUF_SIZE` bytes into the input buffer
 *      - pass that buffer to `parse()` (bail if return < 0)
 */
int main(int argc, char** argv)
{
# define POMD4C_OPTIONS "hvp:e:"

    int ch;
    memset(&config, 0, sizeof(config));
    config.tmpdir = getenv("TMPDIR");

    while ((ch = getopt(argc, argv, POMD4C_OPTIONS)) != -1) {
        switch (ch) {
            case 'h':
                usage(argv[0]);
                return 0;
            case 'v':
                config.verbose++;
                break;
            case 'p':
                config.post_path = optarg;
                break;
            case 'e':
                add_env_param(optarg);
                break;
            default:
                usage(argv[0]);
                return -1;
        }
    }
    argc -= (optind);
    argv += (optind);

    if( argc < 1 ) {
        ERROR_BAIL_MSG("No input file specified.");
    }

    configure_parser();

    int source_fd = -1;
    for(int i=0; i<argc; i++) {
        errno = 0;

        config.input_path = argv[i];
        char* abs_path = realpath(
                config.input_path, (char*)&config.abs_input_path);
        if( !abs_path ) {
            LOG_WARNING(
                    "Unable to process %s: %s",
                    config.input_path, strerror(errno));
            continue;
        }

        LOG_INFO("Processing: %s", config.input_path);

        source_fd = open(config.input_path, O_RDONLY);
        if( source_fd < 0 ) {
            goto err_bail;
        }

        struct stat source_stat;
        int stat_ok = fstat(source_fd, &source_stat);
        if( stat_ok < 0 ) {
            goto err_bail;
        }

        char* buffer = mmap(0, source_stat.st_size,
                PROT_READ, MAP_FILE | MAP_PRIVATE, source_fd, 0);
        if( buffer == MAP_FAILED ) {
            goto err_bail;
        }

        parser_reset();

        errno = 0;

        /* Invoke the postproc script once with no args to notify we're
         * starting a file:
         */
        pid_t post_pid = fork();
        if( !post_pid ) {
            LOG_DEBUG("Executing: %s (START FILE: %s)",
                    config.post_path, config.abs_input_path);
            setenv("POMD4C_SOURCE", config.abs_input_path, 1);
            setenv("POMD4C_VERSION", POMD4C_VERSION, 1);
            execlp(config.post_path, config.post_path, NULL);
            LOG_ERROR("Failed to launch post proc %s: %s",
                    config.post_path, strerror(errno));
        } else {
            while( (post_pid = waitpid(-1, 0, 0)) > 0 )
            {
                LOG_DEBUG("Waiting on process %i to complete", (int)post_pid);
            }
        }

        if( parse(buffer, source_stat.st_size) < 0 ) {
            LOG_ERROR("Parsing for %s failed at row %zu, column %zu",
                    config.input_path, parser.row, parser.col);
            goto err_bail;
        }

        munmap(buffer, source_stat.st_size);
        close(source_fd);
        source_fd = -1;
    }

    return 0;

err_bail:
    LOG_ERROR("pomd4c encountered an unrecoverable error:\n%s", strerror(errno));
    if( source_fd >=0 ) {
        close(source_fd);
    }
    if( config.post_path ) {
        fclose(config.comment_out);
        fclose(config.source_out);
    }
    return -1;
}

/* EOF: pomd4c.c */

