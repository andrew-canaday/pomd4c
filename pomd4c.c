/*============================================================================*
 * Copyright (c) 2021 Andrew T. Canaday
 *
 * This file is part of pomd4c, which is licensed under the MIT license.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *----------------------------------------------------------------------------*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <sys/errno.h>

/** # POMD4C
 *
 * `pomd4c` is a _very simplistic_ doc generator for C projects, e.g.:
 *
 * This markdown document can be generated by running:
 *
 * ```bash
 * gcc ./pomd4c.c -o ./pomd4c \
 *     && ./pomd4c ./pomd4c.c > ./API.md
 * ```
 *
 * ## Mechanics
 *
 * `pomd4c` is *very* simple — *it is not a C parser or proper document
 * generator*.
 *
 * ### This is all that it does:
 *
 * 1. It reads a file, specified as the only arg on the command line.
 * 1. It emits markdown on `stdout` (errors/debug messages on `stderr`).
 *
 * > :warning: **NOTE**: `pomd4c` _assumes input which has already passed
 * > muster for an actual C parser._ It's not strict or even very robust.
 *
 * The only thing it tries to do is — given a _valid_ C header or source file —
 * figure out which bits are comments and which bits are
 * definitions/declarations immediately following comments.
 *
 * Afterwards, it spits them back out with the C defs wrapped in markdown
 * code fences and the comments emitted verbatim, save for:
 *  - the leading `'/'`, `'*'`, `'*'`, `' '` sequence on the first line
 *  - the first **3** columns of any subsequent lines
 *  - the trailing `'*'`, `'/'`, `'\n'` sequence
 *
 *
 * ### This is how it works:
 *
 * 1. It looks for the character sequence `'/'`, `'*'`, `'*'`.
 *    (i.e. a doc comment start)
 * 1. Then it looks for the sequence `'*'`, `'/'`, `'\n'`.
 *    (i.e. a comment end)
 * 1. Afterwards, it reads whatever follows like so:
 *     - If the next thing that happens is `'\n'` the comment stands on its own.
 *     - Otherwise, it'll read until it reaches a "terminal."
 *
 * Terminals are defined like so:
 *  - If the thing being documented starts with `'#'`, the terminal is `'\n'`.
 *  - Otherwise, the terminal is `';'`.
 *
 * If there are characters in the sequence `"{}()"`, it factors in nesting
 * levels in the most simplistic way possible.
 *
 * That's it!
 *
 * ---
 */

/** # API */

/** ## Definitions
 */

/* Number of columns to skip when mid-comment: */
#ifndef SKIP_COLS
# define SKIP_COLS 3
#endif /* SKIP_COLS */

/* HACK: fixed-sized input buffer (read in chunks on a loop) */
#ifndef BUF_SIZE
# define BUF_SIZE 4096
#endif /* BUF_SIZE */

#define POMD4C_DEBUG 1
#if defined(POMD4C_DEBUG) && (POMD4C_DEBUG == 1)
/** Simple debug logging function */
# define LOG_DEBUG(fmt, ...) \
    fprintf(stderr, "DEBUG: "fmt"\n", __VA_ARGS__)
#else
# define LOG_DEBUG(...)
#endif /* POMD4C_DEBUG */

/** Simple error logging function */
#define LOG_ERROR(fmt, ...) \
    fprintf(stderr, "ERROR: "fmt"\n", __VA_ARGS__)

/** Log a formatted string message and `exit(1)`
 */
#define ERROR_BAIL(fmt, ...) \
    LOG_ERROR(fmt, __VA_ARGS__); \
    exit(1)

/** Log a plain string message and `exit(1)` */
#define ERROR_BAIL_MSG(msg) ERROR_BAIL("%s", msg)

/** ## Types
 */

/** ### parser_state_t
 *
 * Enum used to track the present state of the parser.
 */
typedef enum parser_state {
    PARSE_FILE,          /* Looking for doc comment start */
    PARSE_OPEN_SLASH,    /* Saw the initial '/', looking for '*' */
    PARSE_STAR,          /* Saw '*' after '/', looking for another */
    PARSE_SPACE,         /* Saw '*' after '*', looking for a space */
    PARSE_COMMENT,       /* Parsing comment def_pre (skips first 3 columns) */
    PARSE_NEWLINE,       /* Looking for newline after comment */
    PARSE_DEF_START,     /* Def parsing (optional) begins (skips leading ' ')*/
    PARSE_DEF            /* Parsing the actual C def, looking for a terminal */
} parser_state_t;

static const char* STATE_NAMES[] = {
    "PARSE_FILE",
    "PARSE_OPEN_SLASH",
    "PARSE_STAR",
    "PARSE_SPACE",
    "PARSE_COMMENT",
    "PARSE_NEWLINE",
    "PARSE_DEF_START",
    "PARSE_DEF"
};

/** ### parse_info_t
 *
 * Struct used to encapsulate parser information/house output buffer.
 */
typedef struct parse_info {
    /* parser/input info: */
    parser_state_t state;             /* Current parser state */
    char           buffer[BUF_SIZE];  /* Parse temp buffer */
    size_t         row;               /* Row number in the input. */
    size_t         col;               /* Column number in the input. */
    ssize_t        nest_lvl;          /* Tracks nesting */

    /* content pointers: */
    const char*    heading;           /* Heading, if present */
    const char*    summary;           /* First line of comment */
    const char*    def_pre;           /* Remainder of comment (optional) */
    const char*    def_post;          /* Post def content (optional) */
    const char*    def;               /* Beginning of C def (optional) */

    /* parse state specifics: */
    char*          recv;              /* Current input pointer for buffer */
    char           terminal;          /* PARSE_DEF terminal we're looking for */
    char           last_saved;        /* Last char actually stored in buffer */
    char           last_seen;         /* Last char actually seen in file */
    char           nest_char;         /* Char used to increase nest level */
    int            is_macro;          /* Flag indicating macro def vs other */
} parse_info_t;


/** ## Functions
 */

/** ### parser_reset
 *
 * Reset the parser to initial state.
 */
static void parser_reset(parse_info_t* parser);

/** ### parser_write
 *
 * Unconditionally write a single character to the parser's output buffer.
 *
 *  - `parser` a pointer to the current `parse_info_t`
 *  - `c` the character to write to the buffer
 */
static void parser_write(parse_info_t* parser, char c);

/** ### parser_write_comment
 *
 * Write a single character to the parser's output buffer IF the character is
 * a newline or the current column is greater than SKIP_COLS.
 *
 *  - `parser` a pointer to the current `parse_info_t`
 *  - `c` the character to write to the buffer
 */
static int parser_write_comment(parse_info_t* parser, char c);

/** ### parser_emit
 *
 * Emit the parsers output buffer as markdown.
 */
static void parser_emit(parse_info_t* parser);

/** ### parse_comment
 *
 * Invoked by `parse` to parse a comment def_post.
 */
static void parse_comment(parse_info_t* parser, char c);

/** ### parse_def_start
 *
 * Invoked by `parse` to look for a C def after a comment end.
 */
static void parse_def_start(parse_info_t* parser, char c);

/** ### parse_def
 *
 * Invoked by `parse` to parse a C def.
 */
static void parse_def(parse_info_t* parser, char c);

/** ### parse
 *
 * Parse the given input buffer.
 */
static ssize_t parse(parse_info_t* parser, char* read_buf, size_t len);


/*--------------------------------------------------
 * Functions:
 *--------------------------------------------------*/
static void parser_reset(parse_info_t* parser)
{
    memset(parser, 0, sizeof(parse_info_t));
    parser->recv = parser->buffer;
    parser->state = PARSE_FILE;
    parser->row = 1;
    parser->col = 0;
    return;
}


static void parser_write(parse_info_t* parser, char c)
{
    *(parser->recv++) = c;
    parser->last_saved = c;
    return;
}


static int parser_write_comment(parse_info_t* parser, char c)
{
    if( c == '\n' || parser->col > SKIP_COLS ) {
        parser_write(parser, c);
        return 1;
    }
    return 0;
}

static void parser_emit(parse_info_t* parser)
{
    /* Heading (optional) */
    if( parser->heading ) {
        printf("\n%s\n", parser->heading);
    }

    /* Summary: the only thing, if there's anything at all. */
    printf("%s\n", parser->summary);

    if( parser->def_pre ) {
        printf("\n%s\n", parser->def_pre);
    }

    /* Def: the C definition/declaration (optional) */
    if( parser->def ) {
        printf("\n```C\n%s\n```\n", parser->def);
    }

    /* The post-def comment body (optional) */
    if( parser->def_post ) {
        printf("\n%s\n", parser->def_post);
    }

    puts("\n");
    return;
}


static void parse_comment(parse_info_t* parser, char c)
{
    /* Check for end-of-comment: */
    if( c == '/' && parser->last_seen == '*' ) {
        /* Delete that last '*' and write string terminal: */
        parser->recv--;
        parser_write(parser, '\0');
        parser->def = parser->recv;
        parser->state++;
    } else {
        parser_write_comment(parser, c);
    }
    return;
}


static void parse_def_start(parse_info_t* parser, char c)
{
    /* If no terminal is set, we haven't seen a char we care too much about
     * so...
     */
    if( parser->terminal == '\0' ) {
        switch(c) {
            /* 1. Skip most whitespace */
            case ' ':
                /* fallthrough */
            case '\t':
                /* fallthrough */
            case '\r':
                return;
            /* If the character is '#', assume a macro: */
            case '#':
                parser->terminal = '\n';
                parser->is_macro = 1;
                break;
            /* Otherwise, we got something else; look for a ';': */
            default:
                parser->terminal = ';';
        }
    }

    /* Otherwise... */
    switch(c) {
        /* If we hit a newline before anything else: give up on defs + emit. */
        case '\n':
            parser->def = NULL;
            parser_emit(parser);
            parser_reset(parser);
            return;
        /* Else, ignore leading spaces. */
        case ' ':
            return;
        /* Okay! We've got something substantive; start parsing the def. */
        default:
            parser_write(parser, c);
            parser->state++;
            break;
    }
    return;
}


static void parse_def(parse_info_t* parser, char c)
{
    /* If we haven't already decided if we're nested or what characters
     * we're using to check for nesting, check to see if the present
     * character is in "({" and set things up to track nesting. Else, move on.
     */
    if( parser->nest_lvl == 0 ) {
        switch(c) {
            case '(':
                parser->nest_char = '(';
                parser->terminal = ')';
                break;
            case '{':
                parser->nest_char = '{';
                parser->terminal = '}';
                break;
            default:
                break;
        }
    }

    /* If we *are* nested and this is the top-level nesting char, go ahead and
     * increment the nesting level.
     */
    if( c == parser->nest_char ) {
        parser->nest_lvl++;
    }

    /* If this is the apparent end of the C def.... */
    if( c == parser->terminal ) {
        switch( parser->terminal ) {
            /* If the terminal is either of our "nesting characters", make
             * note of it, decrement the nesting count, and swap back to
             * whatever the previous terminal was — i.e. '\n' for a macro and
             * ';' otherwise.
             */
            case '\n':
                break;
            case '}':
                /* fallthrough */
            case ')':
                parser->nest_lvl--;
                parser_write(parser, c); /* Whatever it is, write it. */
                if( parser->nest_lvl == 0 ) {
                    if( !parser->is_macro ) {
                        parser->terminal = ';';
                        return;
                    }
                }
                break;
            case ';':
                /* Okay, this means we're done with a non-macro def: */
                parser_write(parser, c);
                break;
            default:
                break;
        }

        parser_write(parser, '\0');
        parser_emit(parser);
        parser_reset(parser);
    } else {
        parser_write(parser, c);
    }
    return;
}


static ssize_t parse(parse_info_t* parser, char* read_buf, size_t len)
{
    char* src = read_buf;
    size_t idx = 0;
    for(idx=0; idx < len; idx++ ) {
        /* HACK HACK: Store the last character, if there was one. */
        if( idx > 0 ) {
            parser->last_seen = *(src-1);
        }

        char c = *src++;

        if( c == '\n' ) {
            parser->row++;
            parser->col = 0;
        } else {
            parser->col++;
        }

        switch(parser->state) {
            case PARSE_FILE:
                /* Chug along until we hit a '/' */
                if( c == '/' ) {
                    parser->state++;
                }
                break;
            case PARSE_OPEN_SLASH:
                /* We got a '/', so expect a '*'; else: reset! */
                if( c == '*' ) {
                    parser->state++;
                } else {
                    parser_reset(parser);
                }
                break;
            case PARSE_STAR:
                /* We got a '*', so expect another; else: reset! */
                if( c == '*' ) {
                    parser->state++;
                } else {
                    parser_reset(parser);
                }
                break;
            case PARSE_SPACE:
                /* We got a second '*', so expect ' '; else: reset! */
                if( c == ' ' ) {
                    parser->state++;
                    parser->summary = parser->recv;
                } else {
                    parser_reset(parser);
                }
                break;
            case PARSE_COMMENT:
                parse_comment(parser, c);
                break;
            case PARSE_NEWLINE:
                /* If we hit a newline, this comment is just a block of
                 * markdown to emit on its own: */
                if( c == '\n' ) {
                    parser->state++;
                } else {
                    /* Otherwise, start parsing the def text: */
                    parser->def = NULL;
                    parser_emit(parser);
                    parser_reset(parser);
                }
                break;
            case PARSE_DEF_START:
                parse_def_start(parser, c);
                break;
            case PARSE_DEF:
                parse_def(parser, c);
                break;
        }
    }
    return idx;
}


/* main function.
 *
 * All that's happening is:
 *
 *  - check number of args
 *  - open the file whose path is in argv[1]; else bail
 *  - until we've seen `EOF`:
 *      - read `BUF_SIZE` bytes into the input buffer
 *      - pass that buffer to `parse()` (bail if return < 0)
 */
int main(int argc, char** argv)
{
    if( argc < 2 ) {
        ERROR_BAIL_MSG("No input file specified.");
    }

    const char* input_path = argv[1];
    FILE* source_file = fopen(input_path, "r");

    if( !source_file ) {
        ERROR_BAIL("Unable to open file %s: %s", input_path, strerror(errno));
    }

    char buffer[BUF_SIZE];
    size_t bytes_read = 0;
    parse_info_t parser;
    parser_reset(&parser);

    do {
        bytes_read = fread(buffer, 1, BUF_SIZE, source_file);
        if( !bytes_read ) {
            goto close_and_exit;
        }

        if( parse(&parser, buffer, bytes_read) < 0 ) {
            LOG_ERROR("Parsing stopped with %zu bytes read", bytes_read);
            goto close_and_exit;
        }
    } while( bytes_read > 0 );

close_and_exit:
    fclose(source_file);
    return 0;
}

/* EOF: pomd4c.c */

