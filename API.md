# POMD4C

`pomd4c` is a _very simplistic_ doc generator for C projects, e.g.:

This markdown document can be generated by running:

```bash
gcc ./pomd4c.c -o ./pomd4c \
    && ./pomd4c ./pomd4c.c > ./API.md
```

## Mechanics

`pomd4c` is *very* simple — *it is not a C parser or proper document
generator*.

### This is all that it does:

1. It reads a file, specified as the only arg on the command line.
1. It emits markdown on `stdout` (errors/debug messages on `stderr`).

> :warning: **NOTE**: `pomd4c` _assumes input which has already passed
> muster for an actual C parser._ It's not strict or even very robust.

The only thing it tries to do is — given a _valid_ C header or source file —
figure out which bits are comments and which bits are
definitions/declarations immediately following comments.

Afterwards, it spits them back out with the C defs wrapped in markdown
code fences and the comments emitted verbatim, save for:
 - the leading `'/'`, `'*'`, `'*'`, `' '` sequence on the first line
 - the first **3** columns of any subsequent lines
 - the trailing `'*'`, `'/'`, `'\n'` sequence


### This is how it works:

1. It looks for the character sequence `'/'`, `'*'`, `'*'`.
   (i.e. a doc comment start)
1. Then it looks for the sequence `'*'`, `'/'`, `'\n'`.
   (i.e. a comment end)
1. Afterwards, it reads whatever follows like so:
    - If the next thing that happens is `'\n'` the comment stands on its own.
    - Otherwise, it'll read until it reaches the end of the current def.

If there are characters in the sequence `"{}()"`, it factors in nesting
levels in the most simplistic way possible.

That's it!

---


# API 


## Definitions


Simple debug logging function 

```C
# define LOG_TRACE(fmt, ...) \
    fprintf(stderr, "TRACE: "fmt"\n", __VA_ARGS__)
#else
# define LOG_TRACE(...)
#endif /* POMD4C_TRACE */
```


Simple debug logging function 

```C
# define LOG_DEBUG(fmt, ...) \
    fprintf(stderr, "DEBUG: "fmt"\n", __VA_ARGS__)
#else
# define LOG_DEBUG(...)
#endif /* POMD4C_DEBUG */
```


Simple error logging function 

```C
#define LOG_ERROR(fmt, ...) \
    fprintf(stderr, "ERROR: "fmt"\n", __VA_ARGS__)
```


Log a formatted string message and `exit(1)`

```C
#define ERROR_BAIL(fmt, ...) \
    LOG_ERROR(fmt, __VA_ARGS__); \
    exit(1)
```


Log a plain string message and `exit(1)` 

```C
#define ERROR_BAIL_MSG(msg) ERROR_BAIL("%s", msg)
```


Version number as hex (most to least significant):

- major version
- minor version
- patch level
- release annotation

```C
#define POMD4C_VERSION 0x00010000
```


## Types


### parser_state_t

Enum used to track the present state of the parser.

```C
typedef enum parser_state {
    PARSE_FILE,          /* Looking for doc comment start */
    PARSE_OPEN_SLASH,    /* Saw the initial '/', looking for '*' */
    PARSE_STAR,          /* Saw '*' after '/', looking for another */
    PARSE_SPACE,         /* Saw '*' after '*', looking for a space */
    PARSE_COMMENT,       /* Parsing comment def_pre (skips first 3 columns) */
    PARSE_NEWLINE,       /* Looking for newline after comment */
    PARSE_DEF_START,     /* Def parsing (optional) begins (skips leading ' ')*/
    PARSE_DEF,           /* Parsing the actual C def, looking for a terminal */
    PARSE_DEF_END        /* End of def parsing */
} parser_state_t;
```


### parse_info_t

Struct used to encapsulate parser information/house output buffer.

```C
typedef struct parse_info {
    /* parser/input info: */
    parser_state_t state;             /* Current parser state */
    char           buffer[BUF_SIZE];  /* Parse temp buffer */
    size_t         row;               /* Row number in the input. */
    size_t         col;               /* Column number in the input. */
    ssize_t        nest_lvl;          /* Tracks nesting */

    /* content pointers: */
    const char*    heading;           /* Heading, if present */
    const char*    summary;           /* First line of comment */
    const char*    def_pre;           /* Remainder of comment (optional) */
    const char*    def_post;          /* Post def content (optional) */
    const char*    def;               /* Beginning of C def (optional) */
    size_t         len;               /* Number of bytes written to buffer. */

    /* parse state specifics: */
    char*          recv;              /* Current input pointer for buffer */
    char           terminal;          /* PARSE_DEF terminal we're looking for */
    char           last_saved;        /* Last char actually stored in buffer */
    char           last_seen;         /* Last char actually seen in file */
    int            is_macro;          /* Flag indicating macro def vs other */
} parse_info_t;
```


## Functions


### parser_reset

Reset the parser to initial state.

```C
static void parser_reset(parse_info_t* parser);
```


### parser_write

Unconditionally write a single character to the parser's output buffer.

 - `parser` a pointer to the current `parse_info_t`
 - `c` the character to write to the buffer

```C
static void parser_write(parse_info_t* parser, char c);
```


### parser_write_comment

Write a single character to the parser's output buffer IF the character is
a newline or the current column is greater than SKIP_COLS.

 - `parser` a pointer to the current `parse_info_t`
 - `c` the character to write to the buffer

```C
static int parser_write_comment(parse_info_t* parser, char c);
```


### parser_emit

Emit the parsers output buffer as markdown.

```C
static void parser_emit(parse_info_t* parser);
```


### parse_comment

Invoked by `parse` to parse a comment def_post.

```C
static void parse_comment(parse_info_t* parser, char c);
```


### parse_def_start

Invoked by `parse` to look for a C def after a comment end.

```C
static void parse_def_start(parse_info_t* parser, char c);
```


### parse_def

Invoked by `parse` to parse a C def.

```C
static void parse_def(parse_info_t* parser, char c);
```


### parse

Parse the given input buffer.

```C
static ssize_t parse(parse_info_t* parser, char* read_buf, size_t len);
```


