# POMD4C

`pomd4c` is a _very simplistic_ doc generator for C projects, e.g.:

This markdown document can be generated by running:

```bash
gcc ./pomd4c.c -o ./pomd4c \
    && ./pomd4c ./pomd4c.c > ./API.md
```

## Mechanics

`pomd4c` is a little hack — *it is not a C parser or proper document
generator*.

### This is all that it does:

1. Reads one or more files, specified on the command line.
1. Emits markdown on `stdout` (errors/debug messages on `stderr`).

> :warning: **NOTE**: `pomd4c` _assumes input which has already passed
> muster for an actual C parser._ It's not strict or even very robust.

The only thing it tries to do is — given a _valid_ C header or source file —
figure out which bits are comments and which bits are
definitions/declarations immediately following comments.

Afterwards, it spits them back out with the C defs wrapped in markdown
code fences and the comments emitted verbatim, save for:

 - the leading `'/'`, `'*'`, `'*'`, sequence on the first line
 - the first `POMD4C_SKIP_COLS` columns of any subsequent lines
 - the trailing `'*'`, `'/'`, `'\n'` sequence


### This is how it works:

1. It looks for the character sequence `'/'`, `'*'`, `'*'`.
   (i.e. a doc comment start)
1. Then it looks for the sequence `'*'`, `'/'`, `'\n'`.
   (i.e. a comment end)
1. Afterwards, it reads whatever follows like so:
    - If the next thing that happens is `'\n'` the comment stands on its own.
    - Otherwise, it'll read until it reaches the end of the current def/decl.

If there are characters in the sequence `"{}()"`, it factors in nesting
levels in the most simplistic way possible.

That's it!

---

# API 

## Definitions

Standard output, if -v: 


```C
#define LOG_INFO(fmt, ...) \
    do { \
        if( config.verbose > 0 ) { \
            fprintf(stderr, "pomd4c "POMD4C_VERSION": "fmt"\n", __VA_ARGS__); \
        } \
    } while(0)
```

Debug output, if -vv: 


```C
#define LOG_DEBUG(fmt, ...) \
    do { \
        if( config.verbose > 1 ) { \
            fprintf(stderr, "DEBUG: "fmt"\n", __VA_ARGS__); \
        } \
    } while(0)
```

Trace output, if -vvv: 


```C
#define LOG_TRACE(fmt, ...) \
    do { \
        if( config.verbose > 2 ) { \
            fprintf(stderr, "TRACE: "fmt"\n", __VA_ARGS__); \
        } \
    } while(0)
```

Simple warning log function 


```C
#define LOG_WARNING(fmt, ...) \
    fprintf(stderr, "\033[00;34mWARNING: "fmt"\033[00;m\n", __VA_ARGS__)
```

Simple error log function 


```C
#define LOG_ERROR(fmt, ...) \
    fprintf(stderr, "\033[00;31mERROR: "fmt"\033[00;m\n", __VA_ARGS__)
```

Log a formatted string message and `exit(1)`. 


```C
#define ERROR_BAIL(fmt, ...) \
    LOG_ERROR(fmt, __VA_ARGS__); \
    exit(1)
```

Log a plain string message and `exit(1)`. 


```C
#define ERROR_BAIL_MSG(msg) ERROR_BAIL("%s", msg)
```

Version number as a string literal. 


```C
#ifndef POMD4C_VERSION
```

## Types

### parser_state_t

Enum used to track the present state of the parser.


```C
typedef enum parser_state {
    PARSE_FILE,          /* Looking for doc comment start */
    PARSE_OPEN_SLASH,    /* Saw the initial '/', looking for '*' */
    PARSE_STAR,          /* Saw '*' after '/', looking for another */
    PARSE_SPACE,         /* Saw '*' after '*', skip leading spaces */
    PARSE_COMMENT,       /* Parsing comment (skips first 3 columns) */
    PARSE_NEWLINE,       /* Looking for newline after comment */
    PARSE_DEF_START,     /* Def parsing (optional) begins (skips leading ' ')*/
    PARSE_DEF,           /* Parsing the actual C def, looking for a LF */
    PARSE_DEF_END        /* End of def parsing */
} parser_state_t;
```

## Globals 

Runtime config 


```C
static struct {
    unsigned int verbose;                  /* Verbosity */
    unsigned     skip_cols;                /* Number of columns to skip */
#ifdef POMD4C_CTRL_SEQ
    const char*  ctrl_seq;                 /* Control sequence */
#endif /* POMD4C_CTRL_SEQ */
    const char*  post_path;                /* Post-processor path */
    const char*  tmpdir;                   /* User TMPDIR */
    const char*  input_path;               /* The current input file */
    char         abs_input_path[PATH_MAX]; /* Absolute path to current input */
    char         comment_path[PATH_MAX];   /* Path to the comment output */
    char         source_path[PATH_MAX];    /* Path to the source output */
    FILE*        comment_out;              /* Current comment output*/
    FILE*        source_out;               /* Current source output*/
} config;
```

Struct used to encapsulate parser information/house output buffer. 


```C
static struct {
    /* parser/input info: */
    parser_state_t state;             /* Current parser state */
    char           buffer[BUF_SIZE];  /* Parse temp buffer */
    size_t         row;               /* Row number in the input. */
    size_t         col;               /* Column number in the input. */
    ssize_t        nest_lvl;          /* Tracks nesting */

    /* content pointers: */
    const char*    heading;           /* Heading, if present */
    const char*    summary;           /* First line of comment */
    const char*    def;               /* Beginning of C def (optional) */
    size_t         len;               /* Number of bytes written to buffer. */

    /* parse state specifics: */
    char*          recv;              /* Current input pointer for buffer */
    char           last_saved;        /* Last char actually stored in buffer */
    char           last_seen;         /* Last char actually seen in file */
    int            is_macro;          /* Flag indicating macro def vs other */
} parser;
```

## Functions

Prototypes for illustration purposes only.

_**WARNING**: DO NOT EAT. DO NOT INCINERATE._


### parser_reset

Reset the parser to initial state.


```C
static void parser_reset(void);
```

### parser_write

Unconditionally write a single character to the parser's output buffer.

 - `parser` a pointer to the current `parse_info_t`
 - `c` the character to write to the buffer


```C
static void parser_write(char c);
```

### parser_write_comment

Write a single character to the parser's output buffer IF the character is
a newline or the current column is greater than config.skip_cols.

 - `parser` a pointer to the current `parse_info_t`
 - `c` the character to write to the buffer


```C
static int parser_write_comment(char c);
```

### parser_emit

Emit the parsers output buffer as markdown output is STDOUT. Output buffer
is emitted verbatim if -p has been specified.


```C
static void parser_emit(void);
```

### parse_comment

Invoked by `parse` to parse a comment body.


```C
static void parse_comment(char c);
```

### parse_def_start

Invoked by `parse` to look for a C def after a comment end.


```C
static void parse_def_start(char c);
```

### parse_def

Invoked by `parse` to parse a C definition/declaration.


```C
static void parse_def(char c);
```

### parse

Parse the given input buffer.


```C
static ssize_t parse(char* read_buf, size_t len);
```

